1.mysql四大特性 ACID
原子性（atomicity）：事务的操作序列不可再拆分，要么全部提交執行成功，要么全部失败回滚。
一致性（consistency）：数据库总是从一致性状态到另一个一致性状态，它只包含成功事务提交的结果
隔离型（isolation）：事务所做的修改在最终提交一起，对其他事务是不可见的，不同事务互相不影响。事务间的读写靠MySQL的锁机制来保证隔离，事务间的写操作靠MVCC机制（快照读（）、当前读(悲观锁，排他锁)）来保证隔离性。
持久性（durability）：一旦事务提交，则其所做的修改就会永久保存到数据库中,持久性是通过redo log和双写缓冲机制(double write buffer)

實現原理：事務有兩種日誌，一個redo log（於寫式日誌） ,一個是undo log .redo log是重做日志，undo log 是回滾日誌
原子性實現依賴的是undo log
持久性實現的依賴的是redo log,redo log 有數據緩衝區。redo log 有三種級別分別是0-2
隔離性：写写操作，依靠的是锁。写读操作：依靠mvcc机制
一致性：由上面三个目标实现来保证

2.mysql的事務隔離級別
READ UNCOMMITTED（读未提交）：事务的修改，即使没有提交，对其他事务也都是可见的。事务能够读取未提交的数据，这种情况称为脏读。
READ COMMITTED（读已提交）：事务读取已提交的数据，大多数数据库的默认隔离级别。当一个事务在执行过程中，数据被另外一个事务修改，造成本次事务前后读取的信息不一样，这种情况称为不可重复读。
PEPEATABLE READ（可重复读）：这个级别是MySQL的默认隔离级别，它解决了脏读的问题，同时也保证了同一个事务多次读取同样的记录是一致的，但这个级别还是会出现幻读的情况。
幻读是指当一个事务A读取某一个范围的数据时，另一个事务B在这个范围插入行，A事务再次读取这个范围的数据时，会产生幻行。
特别说明：InnoDB和XtraDB存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）解决了幻读问题，它使用间隙锁（next-key locking）锁定查询涉及的行和索引中的间隙，防止幻影行的插入。
SERIALIZABLE（可串行化）：这个事务是最高的隔离级别，它强制事务串行执行，避免了幻读问题。简单来说，SERIALIZABLE会在读取的每一行数据上都加锁，所以可能会导致大量的超时和锁竞争

3.事务的构成
begin 或者 start transaction;/trænˈzækʃn/
commit  //提交
rollback //回滚

3.mysql的樂觀鎖和悲觀鎖
MVCC是多版本并发控制，同一个数据有多个版本，事务开启时看到是哪个版本就看到这个版本，最大的好处是读写不冲突，只有写于写是冲突的，
这个特性可以很大程度上提升性能而乐观锁就是另外一个东西，它是一个前提假设，遇到读写冲突需要回退，
在数据库的实现中，一般使用悲观锁，即：操作数据之前先拿到对应的锁
MVCC 解決讀寫衝突
悲觀鎖：每次获取商品时，对該行數據加排他锁
樂觀鎖：不对该數據加锁。在更新数据的时候需要比较程序中的數據是否相等
实现乐观锁常见的方式：版本号version


4.mysql的锁，谈一谈
  答：行级锁和表级锁和全局锁三种：
      行级锁：innodb引擎 ，有共享锁和排他锁两种，额外还有一种是 间隙锁（Next-Key锁）
             共享锁：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。
             排他锁：允许获取排他锁的事务更新数据，阻止其他事务取得相同的数据集共享读锁和排他写锁。
             gap lock  范围锁
             间隙锁（Next-Key锁）：对于键值在条件范围内但并不存在的记录，会加间隙锁，可以防止幻读
             InnoDB存储引擎的锁的算法有三种
             1.Record lock：单个行记录上的锁
             2.Gap lock：间隙锁，锁定一个范围，不包括记录本身
             3.Next-key lock：record+gap 锁定一个范围，包含记录本身
             4.行鎖可以防止幻讀
      ps:行級鎖變為表級鎖：索引失效，會退化為表級鎖：比如更新多行數據 or like 為更新條件

      間隙鎖（Next-Key锁）：比如字段a 1-9,一個語句更新條件範圍是大於1小於9，這時候另外一個語句更新或者插入a的值在1-9範圍內，是插入不進去的

      表级锁：ＭyISAＭ引擎，可以细分为两种 表锁，元数据锁  元数据锁在版本5.5之后增加的
             行級鎖會退化為表級鎖：並發能力低
      全局锁：全局锁就是对整个数据库实例加锁，场景有用来对数据库的备份。
      其他拓展：
          死锁：两个事务互相等待对方释放资源。
              解决死锁：一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数 innodb_lock_wait_timeout 来设置。
                      另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。
      参考资料：https://blog.csdn.net/ztchun/article/details/100109267

  5.各索引的不同
  索引类型：普通索引，唯一索引，全文索引
  索引方式：哈希索引，B+树索引
  哈希索引：哈希值是一个无序的值，不能进行访问查找
  B+树索引：平衡二叉树演化而来，使用的是二分查找， like的%分号在右边，一定情况下才会用到索引

  6.数据库索引b+树


  7.聯合索引
  a,b 联合索引，生成的是a索引，b索引，优化器会自动排序
  1.區分度的不同
  2.範圍查詢的放後面（SELECT * FROM table WHERE a > 1 and b = 2; 優秀索引是b,a）

  回表查询：普通索引要查询两次，可以利用联合索引，生成的覆盖索引，来避免回表回表查询。都能够命中索引覆盖，无需回表


  8,innodb和myisam
  innodb:主鍵索引外，還有一個輔助索引
  myisam:普通索引

###事务篇
1.ACID了解吗，MySQL是用什么机制保证的？两阶段提交能讲一下嘛？
答：
A原子性：靠undo log来保证（异常或执行失败后进行回滚）。
D持久性：靠redo log来保证（保证当MySQL宕机或停电后，可以通过redo log最终将数据保存至磁盘中）。
I隔离性：事务间的读写靠MySQL的锁机制来保证隔离，事务间的写操作靠MVCC机制（快照读（）、当前读(悲观锁，排他锁)）来保证隔离性。
C一致性：事务的最终目的，即需要数据库层面保证，又需要应用层面进行保证，并且MySQL底层通过两阶段提交事务保证了事务持久化时的一致性。
WAL：WAL的全称是Write- Ahead Logging，它的关键点就是先写日志，再写磁盘。redo log prepare---》binlog---》redo log commit

2.redo log和undo log说一下，什么是WAL技术?
答：持久性redolog，原子性undo log,
WAL，全称是Write-Ahead Logging， 预写日志系统。指的是 MySQL 的写操作并不是立刻更新到磁盘上，而是先记录在日志上，然后在合适的时间再更新到磁盘上。

3.redo log和bin log的区别
答：redo log又称重做日志文件，用于记录事务操作的变化，记录的是数据修改之后的值
binlog记录了对MySQL数据库执行更改的所有操作，但是不包括SELECT和SHOW这类操作

4.MySQL的binlog有几种录入格式？分别有什么区别？
答：statement（ˈsteɪtmənt）, row和mixed
statement：记录每一条sql语句，不需要记录每一行的变化，减少了binlog日志量，节约了I0，提高性能
row:保存每一行变动，不记录上下文信息，数据量大
mixed：先用statement，无法使用再用row

5.MySQL的隔离级别有几种，默认的隔离级别是什么，互联网常用的隔离级别是什么？隔离级别与锁的关系
答：1.读未提交  脏读 RU
读已提交   RC
可重复读  RR 默认级别 引入了间隙锁和mvcc多版本控制来处理脏读，悲观锁，读取数据就加锁。乐观锁用版本号做比对，如果版本号一直就更新，否则消息失效
串行化  效率低
2.常用隔离级别数据推荐的是rc(读已提交)
2.1：在RR隔离级别下，存在间隙锁，导致出现死锁的几率比RC大的多！范围更新会间隙锁
2.2：在RR隔离级别下，条件列未命中索引会锁表！而在RC隔离级别下，只锁行
2.3：在RC隔离级别下，半一致性读(semi-consistent)特性增加了update操作的并发性
2.4：在RC级别下，主从复制binlog 用row格式

6.什么是幻读，脏读，不可重复读呢？MySQL是怎么处理幻读的？
答： 脏读 ：脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据
不可重复读：两个事务读取的同一条记录不一致
幻读：在一次事务里面，多次查询之后，结果集的个数不一致的情况叫做幻读。幻读的重点在于新增或者删除，执行操作前后的记录数不一致。A更新1-10，B插入11，会发现11没被A事务更新到

###锁篇
1.MySQL中有哪几种锁，列举一下？
答：1.表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，
表级锁定分为表共享读锁(共享锁)与表独占写锁(排他锁)。
特点：开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。
2.页级锁
页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录
3.行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大

2.锁分哪几种，行锁是锁在哪里的？
答：1.基本锁 - [ 共享锁（Shared Locks：S锁）和排它锁（Exclusive Locks：X锁）]
1.1：共享锁shared locks(S锁）也称读锁，允许其他事务再加S锁，不允许其他事务再加X锁
对于使用共享锁的事务，其他事务只能读，不可写
如果执行了更新操作则会一直等待，直到当前事务commit或者rollback
如果当前事务也执行了其他事务处于等待的那条sql语句，当前事务将会执行成功，而其他事务会报死锁
并且允许其他锁共存
1.2：排它锁Exclusive Locks(X锁）也称写锁，不允许其他事务再加S锁或者X锁
没有指定主键索引会退化为表级锁     
2.意向锁 - [ intention lock,分为意向共享锁（IS锁）和意向排他锁（IX锁）]
3.行锁 - [ record Locks、gap locks、next-key locks、Insert Intention Locks ]
3.1行级锁：
Record Lock：单个行记录上的锁，只锁定记录本身。是针对索引记录（index record）的锁定
Gap（gap） Lock：间隙锁，锁定一个范围，但不包括记录本身。 目的是为了防止同一个事物的两次当前读，出现幻读的情况
Next-Key Lock（特殊间隙锁）：1+2,锁定一个范围，并锁定记录本身。目的：解决幻读
4.自增锁 - [ auto-inc locks ]
参考：https://blog.csdn.net/taoerchun/article/details/109013032

3.间隙锁了解吗？唯一索引有间隙锁吗？
答：1.间隙锁就是gap lock
间隙锁锁的是个范围(x, y)，搭配上行锁就会变成(x, y]，这也叫next key lock
2.唯一索引有间隙锁

4.数据库的乐观锁和悲观锁你怎么理解的？select for update有什么含义
答：乐观锁：就是很乐观，每次去拿数据的时候都认为别人不会修改。更新时如果version变化了，更新不会成功
悲观锁：假设每一次拿数据，都有认为会被修改，所以给数据库的行或表上锁。要注意for update要用在索引上，不然会锁表。
select for update是排它锁

5.MVCC是什么，是如何实现的，算法说一下？
答：1.思路：MVCC是通过保存数据在某个时间点的快照来进行控制的。使用MVCC就是允许同一个数据记录拥有多个不同的版本。
然后在查询时通过添加相对应的约束条件，就可以获取用户想要的对应版本的数据。
三个隐藏字段，
DB_ROW_ID 是数据库默认为该行记录生成的唯一隐式主键，
DB_TRX_ID 是当前操作该记录的事务 ID
而 DB_ROLL_PTR 是一个回滚指针，用于配合 undo日志，指向上一个旧版本
Read View遵循一个可见性算法，主要是将要被修改的数据的最新记录中的 DB_TRX_ID（即当前事务 ID ）取出来，与系统当前其他活跃事务的 ID 去对比（由 Read View 维护），
如果 DB_TRX_ID 跟 Read View 的属性做了某些比较，不符合可见性，那就通过 DB_ROLL_PTR 回滚指针去取出 Undo Log 中的 DB_TRX_ID 再比较，
即遍历链表的 DB_TRX_ID（从链首到链尾，即从最近的一次修改查起），直到找到满足特定条件的 DB_TRX_ID , 那么这个 DB_TRX_ID 所在的旧记录就是当前事务能看见的最新老版本.

    在不同隔离级别的时候，生成ReadView的时机是不同的
    RC：每次执行时快照读都会重新生成新的ReadView
    RR：只有当第一次事务进行快照读的时候才会生成ReadView，之后的快照读操作都会复用当前的ReadView 
    mvcc用Gap Lock和next-key lock 解决幻读

###索引篇
1.MySQL引擎Innodb和Myisam有哪些区别？
答：1.MyISAM存储引擎的特点是：表级锁、不支持事务和全文索引
2.InnoDB存储引擎的特点是：行级锁、事务安全（ACID兼容）、支持外键、不支持FULLTEXT类型的索引(5.6.4以后版本开始支持FULLTEXT类型的索引)。
InnoDB存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全存储引擎

2.InnoDB引擎的4大特性你能说一下嘛？
答：一：插入缓冲
二：二次写
三：自适应哈希
四：预读

3.了解change buffer 的使用场景吗，说一说
答：写缓冲的目的是降低写操作的磁盘IO，提升数据库性能。
5.7以前只针对insert做了优化；现在对delete和update也有效

4.MySQL的innodb的索引是怎么实现的？为什么用B+树，优点是什么，与B树的区别是什么？
答：平衡二叉树，通过二分查找。
B+树：1.非叶子节点不存储data数据，只存储索引值，这样便于存储更多的索引值
2.叶子节点包含了所有的索引值和data数据
3.叶子节点用指针连接，提高区间的访问性能
区别：b+树的中间节点不保存数据，所以磁盘页能容纳更多节点元素，更“矮胖”；
b+树查询必须查找到叶子节点，b树只要匹配到即可不用管元素位置，因此b+树查找更稳定（并不慢）；
对于范围查找来说，b+树只需遍历叶子节点链表即可，b树却需要重复地中序遍历，如下两图：

5.B+树索引的最底层单元是什么？什么决定了B+树的高度？B+树的叶子节点是单向链表还是双向链表?
答：一个高度为 3 的 B+ 树大概可以存放 1170 × 1170 × 16 = 21902400 行数据
由于一个B+Tree的叶子节点是一个页，所以每个叶子节点之间是一个双向链表的结构

6.聚集索引与非聚集索引的区别
答：聚簇索引：在Innodb中，聚簇索引默认就是主键索引。
没有主键时，会用一个唯一且不为空的索引列做为主键，成为此表的聚簇索引
如果没有这样的索引，InnoDB会隐式定义一个主键来作为聚簇索引。
非聚集索引：非聚集索引与聚集索引的区别在于非聚集索引的叶子节点不存储表中的数据，而是存储该列对应的主键
回表问题：想要查找数据我们还需要根据主键再去聚集索引中进行查找，这个再根据聚集索引查找数据的过程，我们称为回表。

7.非聚集索引一定会回表查询吗？
答：不一定，如果查询语句所要求的字段全部命中了索引，那么就不必再进行回表查询就能拿到所有的请求数据

8.InnoDB引擎中的索引策略
答：1.覆盖索引
1.1：减少树的搜索次数，显著提升查询性能
索引是按照值的顺序存储，所以对于 I/O 密集型的范围查询比随机从磁盘中读取每一行的 I/O 要少很多
索引的条目远小于数据的条目，在索引树上读取会极大的减小数据库的访问量
2.最左前缀
2.1：满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。
3.索引下推
3.1对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数



 索引：https://blog.csdn.net/devcloud/article/details/106437478
 锁：https://blog.csdn.net/weixin_42512509/article/details/112780932
  回表查询：https://www.cnblogs.com/myseries/p/11265849.html