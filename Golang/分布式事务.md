1.事务的特性？
1.原子性 要么一起成功要么一起失败

2.一致性 事务执行前后数据保持一致性状态

3.隔离性 多个事务之间是隔离的，互相不影响

4.持久性 事务一旦提交数据的改变是持久的



2.分布式事务和分布式锁的区别？
分布式事务是解决流程化的问题，分布式锁是解决资源占用问题



3.mysql如何实现本地事务？
1.通过数据库锁的机制，保障事务的隔离性；

2.通过 Redo Log（重做日志）来，保障事务的持久性；

3.通过 Undo Log （撤销日志）来，保障事务的原子性；

4.通过 Undo Log （撤销日志）来，保障事务的一致性；



4.什么是分布式事务？
分布式事务保证分布式系统的数据一致性，分布式系统上一次大的操作由多个小的操作完成，每个小操作都在不同的应用执行，分布式事务就是要保证这些操作要么失败，要么成功。



5.什么是cap定理?
web服务无法同时满足cap定理

c 一致性性(Consistency):更新操作成功并返回客户端完成后，所有节点在同一时间的数据完全一致，不能存在中间状态。

a 可用性(Availability):系统提供的服务必须一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。

p 分区容错性(Partition tolerance):即使出现单个组件无法可用，操作依然可以完成



6.什么是数据一致性?
数据更新成功返回客户端之后，所有节点的数据保持一致，没有中间状态。

强一致性:时刻保证数据一致性

最终一致性:一段时间后保证数据一致性

允许存在部分数据不一致:弱数据一致性



7.为什么分布式系统无法同时保证一致性和可用性？
对于分布式系统而言，分区容错性是一个最基本的要求，因此基本上我们在设计分布式系统的时候只能从一致性（C）和可用性（A）之间进行取舍。



8.什么是base定理？
cap定理的a和p的延伸，通过牺牲一致性来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态。



9.什么是刚性事务和柔性事务？
刚性事务：通常无业务改造，强一致性，原生支持回滚/隔离性，低并发，适合短事务。

XA 协议（2PC、JTA、JTS）、3PC，但由于同步阻塞，处理效率低，不适合大型网站分布式场景



柔性事务：不要求强一致性，而是要求最终一致性，允许有中间状态，也就是Base理论

TCC/FMT、Saga（状态机模式、Aop模式）、本地事务消息、消息事务（半消息）



10.什么是xa？
ax是数据库的分布式事务，强一致性，在整个过程中，数据一直锁住状态，即从prepare到commit、rollback的整个过程中，TM一直把持折数据库的锁，如果有其他人要修改数据库的该条数据，就必须等待锁的释放，存在长事务风险。



11.分布式事务有哪些解决方案？
2pc：二阶段提交，强一致性设计，引入一个事务协调者的角色来协调管理各参与者（也可称之为各本地资源）的提交和回滚，二阶段分别指的是准备和提交两个阶段。同步阻塞，存在长事务风险

准备提交阶段-提交阶段



3pc：在2pc之后多加入预提交阶段，和超时。预提交阶段主要是询问事务参与者是否能正常有条件的执行。

准备提交阶段-预提交阶段-提交阶段



Tcc:2PC 和 3PC 都是数据库层面的，而 TCC 是业务层面的分布式事务，需要自己实现Try - Confirm - Cancel三个方法，存在代码入侵业务紧耦合问题

Try 指的是预留，即资源的预留和锁定，注意是预留。
Confirm 指的是确认操作，这一步其实就是真正的执行了。
Cancel 指的是撤销操作，可以理解为把预留阶段的动作撤销了。


消息事务:RocketMQ很好支持消息事务,本地执行事务前发送消息，本地事务失败则丢弃消息，本地执行成功，消息订阅方执行本地事务，成功之后消费消息。



本地消息表:



12.2pc和3pc的区别？
3pc多加入预提交阶段，和超时



13.Seata 的at模式?
Seata AT分为两阶段，主要逻辑全部在第一阶段，第二阶段主要做回滚或日志清理的工作。

会在每个数据库中维护undo_log表

@GlobalTransactional 注解表示开启分布式事务



14.2pc和Seata的at区别？
at模式是增强版的2pc，第一阶段业务数据和回滚日志记录在同一个本地事务中提交,提交之后就会释放资源