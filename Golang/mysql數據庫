1.mysql四大特性 ACID
原子性（atomicity）：事务的操作序列不可再拆分，要么全部提交，要么全部失败回滚。
一致性（consistency）：数据库总是从一致性状态到另一个一致性状态，它只包含成功事务提交的结果
隔离型（isolation）：事务所做的修改在最终提交一起，对其他事务是不可见的
持久性（durability）：一旦事务提交，则其所做的修改就会永久保存到数据库中,持久性是通过redo log和双写缓冲机制(double write buffer)

2.mysql的事務隔離級別
READ UNCOMMITTED（读未提交）：事务的修改，即使没有提交，对其他事务也都是可见的。事务能够读取未提交的数据，这种情况称为脏读。
READ COMMITTED（读已提交）：事务读取已提交的数据，大多数数据库的默认隔离级别。当一个事务在执行过程中，数据被另外一个事务修改，造成本次事务前后读取的信息不一样，这种情况称为不可重复读。
PEPEATABLE READ（可重复读）：这个级别是MySQL的默认隔离级别，它解决了脏读的问题，同时也保证了同一个事务多次读取同样的记录是一致的，但这个级别还是会出现幻读的情况。
幻读是指当一个事务A读取某一个范围的数据时，另一个事务B在这个范围插入行，A事务再次读取这个范围的数据时，会产生幻行。
特别说明：InnoDB和XtraDB存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）解决了幻读问题，它使用间隙锁（next-key locking）锁定查询涉及的行和索引中的间隙，防止幻影行的插入。
SERIALIZABLE（可串行化）：这个事务是最高的隔离级别，它强制事务串行执行，避免了幻读问题。简单来说，SERIALIZABLE会在读取的每一行数据上都加锁，所以可能会导致大量的超时和锁竞争

3.事务的构成
begin 或者 start transaction;/trænˈzækʃn/
commit  //提交
rollback //回滚

3.mysql的樂觀鎖和悲觀鎖
MVCC是多版本并发控制，同一个数据有多个版本，事务开启时看到是哪个版本就看到这个版本，最大的好处是读写不冲突，只有写于写是冲突的，
这个特性可以很大程度上提升性能而乐观锁就是另外一个东西，它是一个前提假设，遇到读写冲突需要回退，
在数据库的实现中，一般使用悲观锁，即：操作数据之前先拿到对应的锁
MVCC 解決讀寫衝突
悲觀鎖：每次获取商品时，对該行數據加排他锁
樂觀鎖：不对该數據加锁。在更新数据的时候需要比较程序中的數據是否相等
实现乐观锁常见的方式：版本号version


4.mysql的锁，谈一谈
  答：行级锁和表级锁和全局锁三种：
      行级锁：innodb引擎 ，有共享锁和排他锁两种，额外还有一种是 间隙锁（Next-Key锁）
             共享锁：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。
             排他锁：允许获取排他锁的事务更新数据，阻止其他事务取得相同的数据集共享读锁和排他写锁。
             间隙锁（Next-Key锁）：对于键值在条件范围内但并不存在的记录，会加间隙锁，可以防止幻读
      表级锁：ＭyISAＭ引擎，可以细分为两种 表锁，元数据锁  元数据锁在版本5.5之后增加的
             行級鎖會退化為標記鎖
      全局锁：全局锁就是对整个数据库实例加锁，场景有用来对数据库的备份。
      其他拓展：
          死锁：两个事务互相等待对方释放资源。
              解决死锁：一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数 innodb_lock_wait_timeout 来设置。
                      另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。
      参考资料：https://blog.csdn.net/ztchun/article/details/100109267

  5.各索引的不同

  6.数据库索引b+树

  7.聯合索引
  1.區分度的不同
  2.範圍查詢的放後面（SELECT * FROM table WHERE a > 1 and b = 2; 優秀索引是b,a）


 索引：https://blog.csdn.net/devcloud/article/details/106437478