#基础篇
1.一条SQL语句在MySQL中如何执行的？
答：
•连接器： 身份认证和权限相关(登录 MySQL 的时候)。
•查询缓存:  执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。
•分析器:  没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。
•优化器： 按照 MySQL 认为最优的方案去执行。
•执行器:  执行语句，然后从存储引擎返回数据。
对于查询等过程如下：权限校验---》查询缓存---》分析器---》优化器---》权限校验---》执行器---》
对于更新等语句执行流程如下：分析器----》权限校验----》执行器---》Undo log -》引擎---redo log prepare---》binlog---》redo log commit

2.说一下数据库的三大范式

3.count(1)、count(*) 与 count(列名) 的区别？
答：列名为主键，count(列名)会比count(1)快
   count(1)和count(*)优化器会自动优化
   count(列名)会忽略为null的那一行，其他的不会
 
4.MySQL中int(20)和char(20)以及varchar(20)的区别
答：varchar属于可变长的字符类型。
    char属于固定长度的字符类型
   
5.分组查询需要注意条件？

###事务篇
1.ACID了解吗，MySQL是用什么机制保证的？两阶段提交能讲一下嘛？
答：
A原子性：靠undo log来保证（异常或执行失败后进行回滚）。
D持久性：靠redo log来保证（保证当MySQL宕机或停电后，可以通过redo log最终将数据保存至磁盘中）。
I隔离性：事务间的读写靠MySQL的锁机制来保证隔离，事务间的写操作靠MVCC机制（快照读（）、当前读(悲观锁，排他锁)）来保证隔离性。
C一致性：事务的最终目的，即需要数据库层面保证，又需要应用层面进行保证，并且MySQL底层通过两阶段提交事务保证了事务持久化时的一致性。
WAL：WAL的全称是Write- Ahead Logging，它的关键点就是先写日志，再写磁盘。redo log prepare---》binlog---》redo log commit

2.redo log和undo log说一下，什么是WAL技术?
答：持久性redolog，原子性undo log,
WAL，全称是Write-Ahead Logging， 预写日志系统。指的是 MySQL 的写操作并不是立刻更新到磁盘上，而是先记录在日志上，然后在合适的时间再更新到磁盘上。

3.redo log和bin log的区别
答：redo log又称重做日志文件，用于记录事务操作的变化，记录的是数据修改之后的值
    binlog记录了对MySQL数据库执行更改的所有操作，但是不包括SELECT和SHOW这类操作

4.MySQL的binlog有几种录入格式？分别有什么区别？
答：statement（ˈsteɪtmənt）, row和mixed
  statement：记录每一条sql语句，不需要记录每一行的变化，减少了binlog日志量，节约了I0，提高性能
  row:保存每一行变动，不记录上下文信息，数据量大
  mixed：先用statement，无法使用再用row
  
5.MySQL的隔离级别有几种，默认的隔离级别是什么，互联网常用的隔离级别是什么？隔离级别与锁的关系
答：1.读未提交  脏读 RU
    读已提交   RC
    可重复读  RR 默认级别 引入了间隙锁和mvcc多版本控制来处理脏读，悲观锁，读取数据就加锁。乐观锁用版本号做比对，如果版本号一直就更新，否则消息失效
    串行化  效率低
    2.常用隔离级别数据推荐的是rc(读已提交)
     2.1：在RR隔离级别下，存在间隙锁，导致出现死锁的几率比RC大的多！范围更新会间隙锁
     2.2：在RR隔离级别下，条件列未命中索引会锁表！而在RC隔离级别下，只锁行
     2.3：在RC隔离级别下，半一致性读(semi-consistent)特性增加了update操作的并发性
     2.4：在RC级别下，主从复制binlog 用row格式 
    
6.什么是幻读，脏读，不可重复读呢？MySQL是怎么处理幻读的？
答： 脏读 ：脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据
     不可重复读：两个事务读取的同一条记录不一致
     幻读：在一次事务里面，多次查询之后，结果集的个数不一致的情况叫做幻读。幻读的重点在于新增或者删除，执行操作前后的记录数不一致。A更新1-10，B插入11，会发现11没被A事务更新到
     
###锁篇
1.MySQL中有哪几种锁，列举一下？
答：1.表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，
       表级锁定分为表共享读锁(共享锁)与表独占写锁(排他锁)。
       特点：开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。
   2.页级锁
  页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录
   3.行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大
   
2.锁分哪几种，行锁是锁在哪里的？
答：1.基本锁 - [ 共享锁（Shared Locks：S锁）和排它锁（Exclusive Locks：X锁）]
     1.1：共享锁shared locks(S锁）也称读锁，允许其他事务再加S锁，不允许其他事务再加X锁
           对于使用共享锁的事务，其他事务只能读，不可写
           如果执行了更新操作则会一直等待，直到当前事务commit或者rollback
           如果当前事务也执行了其他事务处于等待的那条sql语句，当前事务将会执行成功，而其他事务会报死锁
           并且允许其他锁共存
      1.2：排它锁Exclusive Locks(X锁）也称写锁，不允许其他事务再加S锁或者X锁
           没有指定主键索引会退化为表级锁     
    2.意向锁 - [ intention lock,分为意向共享锁（IS锁）和意向排他锁（IX锁）]
    3.行锁 - [ record Locks、gap locks、next-key locks、Insert Intention Locks ]
     3.1行级锁：
         Record Lock：单个行记录上的锁，只锁定记录本身。是针对索引记录（index record）的锁定
         Gap（gap） Lock：间隙锁，锁定一个范围，但不包括记录本身。 目的是为了防止同一个事物的两次当前读，出现幻读的情况
         Next-Key Lock（特殊间隙锁）：1+2,锁定一个范围，并锁定记录本身。目的：解决幻读
    4.自增锁 - [ auto-inc locks ]
参考：https://blog.csdn.net/taoerchun/article/details/109013032

3.间隙锁了解吗？唯一索引有间隙锁吗？
答：1.间隙锁就是gap lock
    间隙锁锁的是个范围(x, y)，搭配上行锁就会变成(x, y]，这也叫next key lock
    2.唯一索引有间隙锁

4.数据库的乐观锁和悲观锁你怎么理解的？select for update有什么含义
答：乐观锁：就是很乐观，每次去拿数据的时候都认为别人不会修改。更新时如果version变化了，更新不会成功
   悲观锁：假设每一次拿数据，都有认为会被修改，所以给数据库的行或表上锁。要注意for update要用在索引上，不然会锁表。
   select for update是排它锁

5.MVCC是什么，是如何实现的，算法说一下？
答：1.思路：MVCC是通过保存数据在某个时间点的快照来进行控制的。使用MVCC就是允许同一个数据记录拥有多个不同的版本。
    然后在查询时通过添加相对应的约束条件，就可以获取用户想要的对应版本的数据。
    三个隐藏字段，
    DB_ROW_ID 是数据库默认为该行记录生成的唯一隐式主键，
    DB_TRX_ID 是当前操作该记录的事务 ID 
    而 DB_ROLL_PTR 是一个回滚指针，用于配合 undo日志，指向上一个旧版本
    Read View遵循一个可见性算法，主要是将要被修改的数据的最新记录中的 DB_TRX_ID（即当前事务 ID ）取出来，与系统当前其他活跃事务的 ID 去对比（由 Read View 维护），
    如果 DB_TRX_ID 跟 Read View 的属性做了某些比较，不符合可见性，那就通过 DB_ROLL_PTR 回滚指针去取出 Undo Log 中的 DB_TRX_ID 再比较，
    即遍历链表的 DB_TRX_ID（从链首到链尾，即从最近的一次修改查起），直到找到满足特定条件的 DB_TRX_ID , 那么这个 DB_TRX_ID 所在的旧记录就是当前事务能看见的最新老版本.
    
    在不同隔离级别的时候，生成ReadView的时机是不同的
    RC：每次执行时快照读都会重新生成新的ReadView
    RR：只有当第一次事务进行快照读的时候才会生成ReadView，之后的快照读操作都会复用当前的ReadView 
    mvcc用Gap Lock和next-key lock 解决幻读

###索引篇
1.MySQL引擎Innodb和Myisam有哪些区别？
答：1.MyISAM存储引擎的特点是：表级锁、不支持事务和全文索引
    2.InnoDB存储引擎的特点是：行级锁、事务安全（ACID兼容）、支持外键、不支持FULLTEXT类型的索引(5.6.4以后版本开始支持FULLTEXT类型的索引)。
      InnoDB存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全存储引擎
      
2.InnoDB引擎的4大特性你能说一下嘛？
答：一：插入缓冲
  二：二次写
  三：自适应哈希
  四：预读
  
3.了解change buffer 的使用场景吗，说一说
答：写缓冲的目的是降低写操作的磁盘IO，提升数据库性能。
    5.7以前只针对insert做了优化；现在对delete和update也有效

4.MySQL的innodb的索引是怎么实现的？为什么用B+树，优点是什么，与B树的区别是什么？
答：平衡二叉树，通过二分查找。
    B+树：1.非叶子节点不存储data数据，只存储索引值，这样便于存储更多的索引值
          2.叶子节点包含了所有的索引值和data数据
          3.叶子节点用指针连接，提高区间的访问性能
    区别：b+树的中间节点不保存数据，所以磁盘页能容纳更多节点元素，更“矮胖”；
          b+树查询必须查找到叶子节点，b树只要匹配到即可不用管元素位置，因此b+树查找更稳定（并不慢）；
          对于范围查找来说，b+树只需遍历叶子节点链表即可，b树却需要重复地中序遍历，如下两图：      

5.B+树索引的最底层单元是什么？什么决定了B+树的高度？B+树的叶子节点是单向链表还是双向链表?
答：一个高度为 3 的 B+ 树大概可以存放 1170 × 1170 × 16 = 21902400 行数据
    由于一个B+Tree的叶子节点是一个页，所以每个叶子节点之间是一个双向链表的结构

6.聚集索引与非聚集索引的区别
答：聚簇索引：在Innodb中，聚簇索引默认就是主键索引。
     没有主键时，会用一个唯一且不为空的索引列做为主键，成为此表的聚簇索引
     如果没有这样的索引，InnoDB会隐式定义一个主键来作为聚簇索引。
     非聚集索引：非聚集索引与聚集索引的区别在于非聚集索引的叶子节点不存储表中的数据，而是存储该列对应的主键
     回表问题：想要查找数据我们还需要根据主键再去聚集索引中进行查找，这个再根据聚集索引查找数据的过程，我们称为回表。
  
7.非聚集索引一定会回表查询吗？
答：不一定，如果查询语句所要求的字段全部命中了索引，那么就不必再进行回表查询就能拿到所有的请求数据

8.InnoDB引擎中的索引策略
答：1.覆盖索引
     1.1：减少树的搜索次数，显著提升查询性能
         索引是按照值的顺序存储，所以对于 I/O 密集型的范围查询比随机从磁盘中读取每一行的 I/O 要少很多
         索引的条目远小于数据的条目，在索引树上读取会极大的减小数据库的访问量
     2.最左前缀
      2.1：满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。 
     3.索引下推
      3.1对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数  
9.索引类型
  字段特性
  1.唯一索引
  2.普通索引 unique
  3.前缀索引  字符串类型，前面几个字符
  
	  
	  

###索引的创建原则
1.索引什么情况下失效，联合索引什么时候失效，覆盖索引、回表等这些，了解过吗？
答：1.索引失效情况
     1.1：like查询%在左边不走
     1.2：查询条件里面计算
     1.3：查询条件里面用函数
     1.4：索引列用了!= 不走索引
     1.5：where出来的数据太多
     1.6：or如果俩个字段中有一个没有索引的话,引擎会放弃索引而产生全表扫描
   2.联合索引失效
   不在索引列上做任何操作（计算、函数、（自动or手动）类型转换），会导致索引失效而转向全表扫描
   存储引擎不能使用索引范围条件右边的列
   尽量使用覆盖索引（只访问索引的查询（索引列和查询列一致）），减少select *
   mysql在使用不等于（！=或者<>）的时候无法使用索引会导致全表扫描
   is null,is not null也无法使用索引
   like以通配符开头（’%abc…’）mysql索引失效会变成全表扫描的操作
     
2.为什么不用UUID做主键，影响的写入性能还是读取性能？如果业务上能保证唯一性，那么还需要建唯一索引吗？会影响写入性能吗？
答：uuid无序，引起不断的频繁的做页分裂操，产生数据碎片。
    唯一索引的写涉及到change buffer的知识，可以查看：https://blog.csdn.net/weixin_36111194/article/details/113197304

3.MySQL 自增主键什么情况下顺序会出现断裂？
答：删除数据但是不重启数据库的情况下会产生断裂

4.假设一个a+b+c 的组合索引，只用 b+c 可以查到吗?
答：不满足最左前缀，查不到

###TroubleShooting&&优化篇
1.慢查询怎么处理？explain的type有几种类型，你常见的有哪几种？
答：慢查询优化处理。
explain的type类型：all,index,range,ref

2.MySQL的高可用是怎么做的
答：主从切换

4.MySQL 遇到过死锁问题吗，你是如何解决的？
答：1.设置事务超时时间  2.手动释放一个锁

5.数据库自增主键可能遇到什么问题？自增主键用完了怎么办？

6.MySQL数据库CPU飙升的话，需要怎么处理？

7.你们的MySQL数据量有多大，如果某个表有近千万数据，如何分库分表？

超大分页怎么处理？
你是如何监控你们的数据库的？你们的慢日志都是怎么查询的？
分库分表以后如何查询，如何做分布式事务
MySQL主从同步的过程是什么样的？
MySQL的主从延迟，你知道怎么解决吗？
日常工作中你是怎么优化SQL的？
Explain执行计划是做什么的？可以说一下嘛？
你知道Profile吗？使用场景是什么呢？
项目中数据库连接池是怎么用的?为什么需要数据库连接池呢

