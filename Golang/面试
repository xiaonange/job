1.new 和make的差别
 答：new返回的是一个类型分配的内存的指针，make用来对map,切片，channel的分配和初始化

2.go内存管理
答：垃圾回收：三色并发标记法，避免了标记法的卡顿

3.函数变量传递用指针还是用值
答：看场景，需要改变上层的值，传指针，减少拷贝。只是单纯参数，正常传变量。指针传递可能引起内存逃逸

4.go的内存逃逸
答：内存逃逸指的是栈上的分配空间不够，或者是原本在栈上申请的空间变为在推上申请。
   1. 指针逃逸  函数返回结果，变量还复用
   2.申请的栈太大
   3.动态类型逃逸 interface
   4.闭包引用对象逃逸
   逃逸分析可以减少gc操作，栈上分配内存比在堆中分配内存有更高的效率，栈上分配的内存不需要GC处理。

5.go的协程，调度，抢占
答：GMP模型的M就是线程，M默认根据cpu数量限定,内核线程。P processor 调度器，G 协程创建G协程，
    相比java的多线程，开销小，更轻量级。io操作，等待channel,系统调用等待回调，G状态会变化,挂起等待，M继续接受其他的协程G
    通过信号协作的方式
    goroutine抢占时机，只有在垃圾回收的时候和栈扫描的时候

6.go协程有哪些状态
答：Gidle（ˈaɪdl）：表示刚刚分配了Goroutine内存但没有进行初始化，此时状态为空闲状态
    Grunnable（ /'rʌnəbl/ ）：可运行状态，在p的本地队列中等待执行。
    Grunning：代表正在执行程序指令，即Goroutine正在运行，此时Goroutine不在p运行队列中，并取得m、p运行资源，即与m和p完成绑定关系，Goroutine完全使用所在m（线程）的栈空间。
    Gsyscall：也说明Goroutine，但不是执行用户层代码，也是正在执行系统调用，此时Goroutine不在p运行队列中，完全拥有m的栈空间。
    Gwaiting：此时Goroutine没有执行用户代码，即不在p运行队列，只是某个时刻打个标
    Gdead：数量减少时多余的P会变为此状态,类似休眠。协程处理完毕会挂起来待用
    schedule保证了不会退出
    deadlock会进行死锁检测
   参考资料： https://blog.csdn.net/QQ1130141391/article/details/96350019

7.go线程和协程大小
答：1.5版本 线程2M，协程是2KB

8.linux有哪几种线程模型
答：1.多对一(M:1)的用户级线程模型
    2.一对一(1:1)的内核级线程模型
    3.多对多(M:N)的两级线程模型

9.go的线程状态
答：自旋和非自旋

10.go线程oom  内存泄漏
答：一般是代碼邏輯問題，使用pprof，或者火焰圖來查證分析處理，可能原因有：
   1.频繁申请重复对象
   2.并发大，Goroutine 数过多，GC 压力增大，GC 缓慢（1.2以後的go的內存回收不會立即釋放，需要5分鐘）
   3.部署環境導致的內存（linux內核版本，go版本）
   參考資料：https://studygolang.com/articles/29149?fr=sidebar

 11.go裡面的錯誤處理
 答：常規還是一行代碼，三行判斷。也可以用defer和 recover 來實現其他語言的try catch

12.Go实现的互斥锁有两种模式，分别是正常模式和饥饿模式
答：為了防止最後面的wait的Goroutine一直處於等待狀態，当waiter超过 1ms 没有获取到锁，它就会将当前互斥锁切换到饥饿模式，防止等待队列中的waiter被饿死。

13.gin的參數怎麼校驗
答：通過構造一個結構體，定義tag標籤，通過反射來做解析

14.go的interface
答：底層是一個有函數的iface和无函数的eface

15：go的反射實現
答：reflect有兩個結構體一個是type,一個是value.通過reflect.typeOf,reflect.valueOf去獲取對應的值

16.go怎麼通過字符串調用辦法
答：初始化含有辦法的結構體，通過reflect.ValueOf(data).MethodByName("").Call([]reflect.Value{})

17.go的鎖有哪幾種模式？對他的理解
答：sync.Mutex 互斥鎖，sync.RWMutex 讀寫鎖
    1.互斥鎖：兩種操作：获取锁和释放锁,兩種模式：正常模式和饥饿模式,為了防止最後面的wait的Goroutine一直處於等待狀態，当waiter超过 1ms 没有获取到锁，它就会将当前互斥锁切换到饥饿模式
        ，防止等待队列中的waiter被饿死。
     用互斥鎖實現的官方包：sync.map,sync.once
    2.讀寫鎖：四種操作：读上锁 读解锁 写上锁 写解锁
    3.其他：sync.waitgroup裡面定義的辦法和互斥鎖一樣有兩個操作：Lock，unlock,它的Add操作依靠的是原子鎖atomic.AddUint64,輕量級的原子鎖

18：go的channel的用法，對他的理解
答：channel有两种：一种是无缓冲，一种是有缓冲。无缓冲有写入就堵塞等待读取，有缓冲，在缓冲数量未写满前，都可以继续写入，缓冲数量满了再堵塞等待。写入已关闭的channel将报panic
    channel是线程安全的

19：mysql的锁，谈一谈
答：行级锁和表级锁和全局锁三种：
    行级锁：innodb引擎 ，有共享锁和排他锁两种，额外还有一种是 间隙锁（Next-Key锁）
           共享锁：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。
           排他锁：允许获取排他锁的事务更新数据，阻止其他事务取得相同的数据集共享读锁和排他写锁。
           间隙锁（Next-Key锁）：对于键值在条件范围内但并不存在的记录，会加间隙锁，可以防止幻读
    表级锁：ＭyISAＭ引擎，可以细分为两种 表锁，元数据锁  元数据锁在版本5.5之后增加的
           行級鎖會退化為標記鎖
    全局锁：全局锁就是对整个数据库实例加锁，场景有用来对数据库的备份。
    其他拓展：
        死锁：两个事务互相等待对方释放资源。
            解决死锁：一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数 innodb_lock_wait_timeout 来设置。
                    另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。
    参考资料：https://blog.csdn.net/ztchun/article/details/100109267

 20：redis分布式锁
 答：1.基于单Redis节点的分布式锁
   单节点redis，允许锁的偶尔失效，那么使用单Redis节点的锁方案就足够了，简单而且效率高
   2.多节点分布式锁的算法RedLock
   redis之父提出，不完善实际还是要用 N 个完全独立的 Redis 节点，循环写入，增加了token，谁创建谁销毁
   核心：redis是单线程，用setnx判断是否存在这个,锁需要加一个超时时间。lua script 去取出值来判断看是否匹配是否一致，一致才删除。
   重视事务级，用ZooKeeper（/ˈzuːkiːpər/）来做锁

 21：redis模式
 答：有四種模式：單機，主從，哨兵，集群分片模式
     單機：簡單，不追求高可用
     主從：數據同步
     哨兵：主节点存活检测、主从运行情况检测、主从切换，每一秒向監聽服務發一個ping，標記服務狀態，不可用就進行切換
     集群模式：具有 高可用、可扩展性、分布式、容错 等特性。Cluster 集群模式的原理，通过数据分片的方式来进行数据共享问题，同时提供数据复制和故障转移功能。

 22.redis持久化
 答：用aof文件，主從服務




