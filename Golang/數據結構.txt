1.B树
B树：1、根结点至少有两个子节点；
    2、每个非叶子节点并且非根节点最少有m/2个，即内部节点的字节点个数最少也有m/2个。
   3、根节点最少有两个字节点。
   4、有k个关键字(关键字按递增次序排列)的非叶结点恰好有k+1个孩子。
   5、所有叶子节点在同一层，即所有叶子几点高度一致。
B-树：多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键字范围的子结点；所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；

B+树：在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中；
1、B+树非叶子节点不存放数据，只存放keys。
2、B+树的叶子节点之间存在指针相连，而且是单链表

B*树：在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率从1/2提高到2/3；
筆記：
平衡二叉樹：平衡二叉搜索树被称为AVL树(有别于AVL算法),且具有以下性质:它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1
B樹：層級矮了，搜索更快。但是會產生迴旋查找的問題

二叉树：二叉树是每个节点最多有两个子节点的树。 二叉树的叶子节点有0个字节点，二叉树的根节点或者内部节点有一个或者两个字节点

二叉查找树(二叉搜索树):它或者是一棵空树，或者是具有下列性质的二叉树：若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；它的左、右子树也分别为二叉搜索树。

平衡二叉树：所有节点的左右子树的高度差小于1的二叉树

平衡二叉树升级到这个b树，解决了树的高度问题




2.递归

3.二分查找
复杂度：O(logn)，当数据增大n倍时，耗时增大logn倍（这里的log是以2为底的）

4.hash
复杂度：O(1)就是最低的时空复杂度
开放寻址法：该方法又可以细分为三种 —— 线性寻址、二次探测、随机探测。线性寻址表示出现哈希冲突之后，就去寻找下一个空的哈希地址；
线性寻址步长是 1，二次探测步长是线性寻址步长的 2 次方，其它逻辑一样；同理，随机探测每次步长随机。不管哪种探测方法，哈希表中空闲位置不多的时候，哈希冲突的概率就会提高，
为了保证操作效率，我们会尽可能保证哈希表中有一定比例的空闲槽位，我们用装载因子来表示空位的多少，装载因子=填入元素/哈希表长度，装载因子越大，表明空闲位置越少，冲突越多，哈希表性能降低。
再哈希函数法：发生哈希冲突后，换一个哈希函数计算哈希值
链地址法：发生哈希冲突后，将对应数据链接到该哈希值映射的上一个值之后，即将哈希值相同的元素放到相同槽位对应的链表中。链地址法即使在哈希冲突很多的情况下，也可以保证将所有数据存储到哈希表中，但是也引入了遍历单链表带来性能损耗。


树的知识参考：https://www.cnblogs.com/williamjie/p/11081096.html