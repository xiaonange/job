
1.简介

2.原理
 2.1：天生分布式胚子，节点有序，递增性
   Zookeeper的每一个节点，都是一个天然的顺序发号器
   
 2.2节点监听机制，可以保障占有锁的方式有序而且高效
  Zookeeper这种首尾相接，后面监听前面的方式，可以避免羊群效应。所谓羊群效应就是每个节点挂掉，所
  有节点都去监听，然后做出反映，这样会给服务器带来巨大压力，所以有了临时顺序节点，当一个节点挂掉，
  只有它后面的那一个节点才做出反映
  
 3.使用方式
 1、保持独占，就是所有试图来获取这个锁的客户端，最终只有一个可以成功获得这把锁。通常的做法是把zk上的一个znode看作是一把锁，
    通过create znode的方式来实现。所有客户端都去创建 /distribute_lock 节点，最终成功创建的那个客户端也即拥有了这把锁。
    
 2、控制时序就是所有视图来获取这个锁的客户端，最终都是会被安排执行，只是有个全局时序了。
 做法和上面基本类似，只是这里 /distribute_lock 已经预先存在，客户端在它下面创建临时顺序节点。
  Zk的父节点（/distribute_lock）维持一份sequence,保证子节点创建的时序性，从而也形成了每个客户端的全局时序
  
  	create -s -e /distribute_lock/lock- data
  	1、每个试图加锁的客户端都会创建一个临时顺序节点 /distribute_lock/lock-xxxxx，并且zk可以保证序号连续且唯一；
  	2、然后获取 /distribute_lock/ 下的所有子节点，并按从小到大排序list；
  	3、判断最小节点是不是自己，如果是，证明你就获取锁了，可以去处理业务逻辑了；
  	4、如果不是，获取到list中你的上一个节点名称(不一定是 -1 的那一个，因为此时它对应的客户端有可能主动放弃了)，对其实施
  	监听操作 get /distribute_lock/lock-xxxxx watch 如果get监听失败了，说明节点已经别清除了，重复 2,3 直到监听成功
  	或者获取锁，如果监听成功，就在这里阻塞，等待通知；
  	5、如果通知过来了，重复 2,3,4 的步骤，直到获取锁，因为上一个节点被释放的原因并不一定是它得到锁-使用完-释放，有可能
  	是客户端断开连接了；
  	6、锁用完后记得主动清除，不然要等到心跳检测的时候才会清除。

