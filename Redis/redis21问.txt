1.字符串  string
  int : 数字
  raw ：长字符大于39个字节
  embstr: 短字符小于39个字节  
  raw和embstr都是sds内存分配，唯一不同的是raw是redis object 和sds各分配一块内存，embstr是redis object合在一块内存。
  
2.列表 list
  ziplist: 1.所有对象字符串元素字节小于69字节
           2.所有对象数量不超过512个
  
  双向链表：不满足ziplist即用双向链表
  
3. hash  

 ziplist: 1.所有对象字符串元素字节小于69字节
           2.所有对象数量不超过512个
  
  hash表：不满足ziplist即用双向链表
  
4.set  无序列表

  inset：1.所有元素都是整数
         2.所有对象数量不超过512个
  
  hash表：不满足inset用hash

  
4.zset  有序列表

  ziplist：1.所有元素长度小于64字节
           2.所有对象数量不超过128个
  
  跳表：不满足ziplist用跳表，调表是双向链表的一个优化，分层链表。

5.缓存雪崩
  大量数据同时失效，大量请求直接打到数据库
  1.设置数据不过期
  2.设置数据错峰失效
  3.定时提前生成缓存数据

6.缓存穿透
 用未有的数据不断恶意请求，redis没有这样的数据，直接大量访问到数据库
  1.参数校验
  2.布隆过滤器

7.缓存击穿
  热点数据失效，大量数据直接打到数据库
  1.热点数据永不过期
  2.互斥锁
  3.用channel通知某个服务做缓存更新，其他线程等待
  
8.redis为啥这么快
  1.数据存储在内存，操作数据快
  2.单线程
  3.合理高效的数据结构
  4.io多路复用模型 epoll
  
9.redis数据失效策略
  定时删除：redis启动一个定时器，定时去扫描遍历key。
           缺点：1.消耗大量cpu io
		         2.如果定时器还没刷到，这时候失效的key还是可以用
	       新版本优化：不扫描全部的key，只随机抽取一部分的key来做检查			 
            
  惰性删除：获取一个key的时候再判断这个key是否过期，过期则删除
  
  内存淘汰机制： allkeys-lru :最近最少使用的key （常用）
                 random: 随机移除
				 no-eviction:禁止驱逐，新写入会报错 （默认）
		
10.redis线程模型

   内部使用文件事件处理器 file event handler,这个文件事件处理器是一个单线程，用io多路复用监听多个scoket,根据scoket上的不同事件选择事件处理器来出来。
  1.监听多个scoket
  2.io多路复用
  3.文件事件分发器 ，事件排队
  4.事件处理器 （连接应答处理，命令请求处理，命令回复处理）
  
11.哨兵模式  sentinel
   哨兵模式是解决redis高可用解决方案  
   
   sentinel作用：
   1.监控，定期检查主从服务状态
   2.提醒
   3.自动故障迁移，把其中一个升级为主服务器
   4.统一的配置管理
   
12.redis 事务

  1.通过watch,exec,multi等命名，通过将几个命令打包，依次，按顺序执行去执行。执行期间不会中断去处理其他命令。 

13.ziplist 压缩列表

ziplist是由一系列特殊编码的连续内存块组成的顺序存储结构。
ziplist类似于双向链表，但是它不存储上一个节点和下一个节点的指针，而是存储上一个节点长度和当前节点长度，通过牺牲部分读写性能，来换取高效的内存空间利用率，节约内存
				 
				 
  
  
  
  
  
   
  
  
  
  
  
  